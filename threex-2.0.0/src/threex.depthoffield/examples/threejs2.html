<!DOCTYPE html>
<body style='margin: 0px; background-color: #000000;overflow: hidden;'>
<script src="../../../vendor/three.js/build/three.min.js"></script>
<script src="../../../vendor/three.js/examples/js/shaders/BokehShader.js"></script>
<script>
	var container;
	var camera, scene, renderer,
		materials = [], objects = [],
		singleMaterial, zmaterial = [],
		parameters, i, j, k, h, color, x, y, z, s, n, nobjects,
		material_depth, cubeMaterial;

	var mouseX = 0, mouseY = 0;

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;

	var height = window.innerHeight;

	var postprocessing = { enabled  : true };

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / height, 1, 3000 );
		camera.position.z = 200;

		scene = new THREE.Scene();

		renderer = new THREE.WebGLRenderer({
			//antialias: false
		});
		renderer.setSize( window.innerWidth, height );
		container.appendChild( renderer.domElement );

		renderer.sortObjects = false;

		material_depth = new THREE.MeshDepthMaterial();

		var path = "textures/cube/SwedishRoyalCastle/";
		var format = '.jpg';
		var urls = [
			path + 'px' + format, path + 'nx' + format,
			path + 'py' + format, path + 'ny' + format,
			path + 'pz' + format, path + 'nz' + format
		];
		var textureCube = THREE.ImageUtils.loadTextureCube( urls );

		parameters = { color: 0xff1100, envMap: textureCube, shading: THREE.FlatShading };
		cubeMaterial = new THREE.MeshBasicMaterial( parameters );

		singleMaterial = false;

		if( singleMaterial ) zmaterial = [ cubeMaterial ];

		var geo = new THREE.SphereGeometry( 1, 20, 10 );

		var start = Date.now();

		renderer.initMaterial( cubeMaterial, scene.__lights, scene.fog );

		var xgrid = 14,
			ygrid = 9,
			zgrid = 14;

		nobjects = xgrid * ygrid * zgrid;

		c = 0;

		//var s = 0.25;
		var scale = 60;

		for ( i = 0; i < xgrid; i ++ )
		for ( j = 0; j < ygrid; j ++ )
		for ( k = 0; k < zgrid; k ++ ) {

			if ( singleMaterial ) {

				mesh = new THREE.Mesh( geo, zmaterial );

			} else {

				materials[ c ] = new THREE.MeshBasicMaterial( parameters );
				mesh = new THREE.Mesh( geo, materials[ c ] );
				renderer.initMaterial( materials[ c ], scene.__lights, scene.fog, mesh );

			}

			x = 200 * ( i - xgrid/2 );
			y = 200 * ( j - ygrid/2 );
			z = 200 * ( k - zgrid/2 );

			mesh.position.set( x, y, z );
			mesh.scale.set( scale, scale, scale );

			mesh.matrixAutoUpdate = false;
			mesh.updateMatrix();

			scene.add( mesh );
			objects.push( mesh );

			c ++;

		}

		//console.log("init time: ", Date.now() - start );

		scene.matrixAutoUpdate = false;

		initPostprocessing();

		renderer.autoClear = false;

		renderer.domElement.style.position = 'absolute';
		renderer.domElement.style.left = "0px";


		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	}

	function onDocumentMouseMove( event ) {
		mouseX = event.clientX - windowHalfX;
		mouseY = event.clientY - windowHalfY;
	}
	function initPostprocessing() {

		postprocessing.scene = new THREE.Scene();

		postprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
		postprocessing.camera.position.z = 100;

		postprocessing.scene.add( postprocessing.camera );

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
		postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, height, pars );
		postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, height, pars );

		var bokeh_shader = THREE.BokehShader;

		postprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms );

		postprocessing.bokeh_uniforms[ "tColor" ].value = postprocessing.rtTextureColor;
		postprocessing.bokeh_uniforms[ "tDepth" ].value = postprocessing.rtTextureDepth;
		postprocessing.bokeh_uniforms[ "focus" ].value = 1.1;
		postprocessing.bokeh_uniforms[ "aspect" ].value = window.innerWidth / height;

		postprocessing.materialBokeh = new THREE.ShaderMaterial( {

			uniforms: postprocessing.bokeh_uniforms,
			vertexShader: bokeh_shader.vertexShader,
			fragmentShader: bokeh_shader.fragmentShader

		} );

		postprocessing.quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh );
		postprocessing.quad.position.z = - 500;
		postprocessing.scene.add( postprocessing.quad );

	}

	function animate() {
		requestAnimationFrame( animate, renderer.domElement );

		var now	= Date.now()/1000;
		var time = Date.now() * 0.0005;

		// camera controls
		camera.position.x += ( +mouseX - camera.position.x ) * 0.036;
		camera.position.y += ( -mouseY - camera.position.y ) * 0.036;
		camera.lookAt( scene.position );

		// change colors based on time
		for( var i = 0; i < nobjects; i ++ ) {
			var hue	= ( 360 * ( i / nobjects + time ) % 360 ) / 360;
			materials[ i ].color.setHSL( hue, 1, 0.5 );
		}
		// actually render the scene
		if( true ){
			renderer.clear();
			// Render scene into texture
			scene.overrideMaterial = null;
			renderer.render( scene, camera, postprocessing.rtTextureColor, true );
			// Render depth into texture
			scene.overrideMaterial = material_depth;
			renderer.render( scene, camera, postprocessing.rtTextureDepth, true );
			// Render bokeh composite
			renderer.render( postprocessing.scene, postprocessing.camera );
		} else {
			renderer.clear();
			renderer.render( scene, camera );
		}
	}
</script></body>
